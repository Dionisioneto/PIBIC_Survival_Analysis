}
# caso contrario, com os resultados
}
for(i in 1: samp){
cat("Realizando iteracao: ", i, "/", samp, "\n", sep = "")
dadosIC <- sim.std.cure.ICdata(n=n, lambda.par=lambda.f, alpha.par=alpha.f,
grid.vet=grid.time, beta.par= beta.f, lambda.parc=1,
theta.par = beta.c , A = 1.5, B = 22.5)
x.f <- cbind(x1=dadosIC$xi1, x2=dadosIC$xi2)
x.c <- cbind(1, x1=dadosIC$xi1, x2=dadosIC$xi2)
grid.obs=time.grid.interval(li=dadosIC$L, ri=dadosIC$R, type="OBS", bmax=length(lambda.f ))
grid.obs=grid.obs[-c(1, length(grid.obs))]
chutes = c(rep(0.1, length(lambda.f)), 1, 1, 0.5, 0.5, 0.5, 0.5)
test <- optim(par = chutes, fn=loglikIC, gr = NULL, method = "BFGS",
control=list(fnscale=-1), hessian = TRUE, l=dadosIC$L,
r=dadosIC$R, x.cure=x.c, x.risk=x.f, grid.vet=grid.obs)
est[i,] <- test$par
prop.cens[i,] = prop.table(table(dadosIC$delta))
prop.cura[i,] = prop.table(table(dadosIC$Y))
vetor.ep = sqrt(diag(solve(-test$hessian)))
matrix.ep[i,] = vetor.ep
}
n = 500
dadosIC <- sim.std.cure.ICdata(n=n, lambda.par=lambda.f, alpha.par=alpha.f,
grid.vet=grid.time, beta.par= beta.f, lambda.parc=lambda.c,
theta.par = beta.c , A = 0.4, B =22)
prop.table(table(dadosIC$delta))
tempo.aval = seq(0,2.5,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = dadosIC$L, R = dadosIC$R,
censored = dadosIC$delta)
prop.table(table(dadosIC$delta))
par(mfrow=c(1,2))
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
turnbull_fit = ic_np(cbind(L, R)~0, data = dadosIC)
plot(turnbull_fit)
n = 500
dadosIC <- sim.std.cure.ICdata(n=n, lambda.par=lambda.f, alpha.par=alpha.f,
grid.vet=grid.time, beta.par= beta.f, lambda.parc=lambda.c,
theta.par = beta.c , A = 0.4, B =22)
prop.table(table(dadosIC$delta))
tempo.aval = seq(0,2.5,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = dadosIC$L, R = dadosIC$R,
censored = dadosIC$delta)
prop.table(table(dadosIC$delta))
par(mfrow=c(1,2))
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
turnbull_fit = ic_np(cbind(L, R)~0, data = dadosIC)
plot(turnbull_fit)
n = 500
dadosIC <- sim.std.cure.ICdata(n=n, lambda.par=lambda.f, alpha.par=alpha.f,
grid.vet=grid.time, beta.par= beta.f, lambda.parc=lambda.c,
theta.par = beta.c , A = 0.4, B =22)
prop.table(table(dadosIC$delta))
tempo.aval = seq(0,2.5,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = dadosIC$L, R = dadosIC$R,
censored = dadosIC$delta)
prop.table(table(dadosIC$delta))
par(mfrow=c(1,2))
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
turnbull_fit = ic_np(cbind(L, R)~0, data = dadosIC)
plot(turnbull_fit)
library(eha)
Theta.matrix = matrix(rep(Theta,samp), ncol = length(Theta), byrow = T)
## esperanca das iteracoes
esperanca.est = apply(est, MARGIN = 2, FUN = mean)
## desvio-padrao dos estimadores
dp.est = apply(est, MARGIN = 2, FUN = sd)
## calculo do vies
Theta.matrix = t(matrix(rep(as.vector(Theta),samp), nrow = 9))
bias.matrix = (est-Theta.matrix)/Theta.matrix*100
## vies (Bias)
bias = colMeans(bias.matrix)
## ---
## coverage probability
## probabilidade de cobertura
## Nivel de 95% de confianca
## ---
## Thetaj +- (quantil_normal_padrao)*(erro-padrao)
nivel.conf = 0.95
quantil = qnorm(p = nivel.conf+((1-nivel.conf)/2), mean=0, sd=1)
limite.superior = est[,] + (quantil*matrix.ep)
limite.inferior = est[,] - (quantil*matrix.ep)
## porcentagem de capturacao do intervalo de confianca para as taxas
prob.cobertura = colMeans(Theta.matrix >= limite.inferior & Theta.matrix <= limite.superior)
matriz.resultados = cbind(Theta,esperanca.est, dp.est, bias, prob.cobertura)
matriz.resultados
summary(prop.cura[,1])
boxplot(prop.cura[,1], ylim = c(0,1))
summary(prop.cens[,1])
boxplot(prop.cens[,1], ylim = c(0,1))
## histogramas
par(mfrow=c(3,3), mai = c(0.6, 0.6, 0.2, 0.1))
hist(est[,1], col = "steelblue", main = "", breaks = 15,
ylab = "Frequência", xlab = expression(hat(lambda)[1]))
hist(est[,2], col = "steelblue", main = "", breaks = 15,
ylab = "Frequência", xlab = expression(hat(lambda)[2]))
hist(est[,3], col = "steelblue", main = "",
ylab = "Frequência", xlab = expression(hat(lambda)[3]))
hist(est[,4], col = "steelblue", main = "", breaks = 15,
ylab = "Frequência", xlab = expression(hat(alpha)))
hist(est[,5], col = "steelblue", main = "", breaks = 15,
ylab = "Frequência", xlab = expression(hat(b)[0]))
hist(est[,6], col = "steelblue", main = "", breaks = 15,
ylab = "Frequência", xlab = expression(hat(b)[1]))
hist(est[,7], col = "steelblue", main = "", breaks = 15,
ylab = "Frequência", xlab = expression(hat(b)[2]))
hist(est[,8], col = "steelblue", main = "", breaks = 15,
ylab = "Frequência", xlab = expression(hat(beta)[1]))
hist(est[,9], col = "steelblue", main = "", breaks = 15,
ylab = "Frequência", xlab = expression(hat(beta)[2]))
par(mfrow=c(3,3))
qqnorm(est[,1], pch = 1, frame = FALSE, main = expression(hat(lambda)[1]),
xlab = "Quantis Teóricos", ylab = "Quantis Observados")
qqline(est[,1], col = "steelblue", lwd = 2)
qqnorm(est[,2], pch = 1, frame = FALSE, main = expression(hat(lambda)[2]),
xlab = "Quantis Teóricos", ylab = "Quantis Observados")
qqline(est[,2], col = "steelblue", lwd = 2)
qqnorm(est[,3], pch = 1, frame = FALSE, main = expression(hat(lambda)[3]),
xlab = "Quantis Teóricos", ylab = "Quantis Observados")
qqline(est[,3], col = "steelblue", lwd = 2)
qqnorm(est[,4], pch = 1, frame = FALSE, main = expression(hat(alpha)),
xlab = "Quantis Teóricos", ylab = "Quantis Observados")
qqline(est[,4], col = "steelblue", lwd = 2)
qqnorm(est[,5], pch = 1, frame = FALSE, main = expression(hat(b)[0]),
xlab = "Quantis Teóricos", ylab = "Quantis Observados")
qqline(est[,5], col = "steelblue", lwd = 2)
qqnorm(est[,6], pch = 1, frame = FALSE, main = expression(hat(b)[1]),
xlab = "Quantis Teóricos", ylab = "Quantis Observados")
qqline(est[,6], col = "steelblue", lwd = 2)
qqnorm(est[,7], pch = 1, frame = FALSE, main = expression(hat(b)[2]),
xlab = "Quantis Teóricos", ylab = "Quantis Observados")
qqline(est[,7], col = "steelblue", lwd = 2)
qqnorm(est[,8], pch = 1, frame = FALSE, main = expression(hat(beta)[1]),
xlab = "Quantis Teóricos", ylab = "Quantis Observados")
qqline(est[,8], col = "steelblue", lwd = 2)
qqnorm(est[,9], pch = 1, frame = FALSE, main = expression(hat(beta)[2]),
xlab = "Quantis Teóricos", ylab = "Quantis Observados")
qqline(est[,9], col = "steelblue", lwd = 2)
## ------
## Funcoes PIBIC 2023
## Projeto: Modelos Semi-Parametricos para dados
## de sobrevivencia com censura intervalar
##
## Aplicacao a censura intervalar
## ------
## ---
## Pacotes
## ---
if(!require(pacman)) install.packages("pacman"); library(pacman)
p_load(eha)
source('C:/Users/NetoDavi/Desktop/survival_pibic/funcoes_sobrevivencia_pibic2023.R')
## ------
## Funcao geradora de dados para censura intervalar
## sem covariaveis
## ------
tamanho.amostral = 600
lambdas = c(0.3, 1.2, 0.6, 0.8)
alpha = 1.4
grid = c(0.3, 0.8, 1.2)
lambda.cens = 0.2
## funcao geradora de dados para censura intervalar, sem covariaveis
sim.IC <- function(n, lambda.param, alpha.param, grid.vector, lambda.cens.param){
t <- rexp(0,n) # tempos de falha
c <- rexp(0,n) # tempos de censura
cens <- rep(1,n) # variiavel indicadora
tempo <- vector(length=n) # tempo observado
t = gen.mepp(n = n, lambda.par = lambda.param, alpha.par = alpha.param,
cuts = grid.vector) # tempo de falha
c = rexp(n, rate = lambda.cens.param) # censura
tempo = pmin(t, c)
#-- Observed times:
delta <- ifelse(t<= c, 1, 0)
L <- R <- tempo * NA
for (i in 1:n) {
if (delta[i] == 0) {
L[i] <- tempo[i]
R[i] <- Inf
}
else {
L[i] <- 0
add <- stats::runif(1, 0.1, 0.5)
R[i] <- add
check <- (L[i] <= tempo[i] & tempo[i] < R[i])
while (!check) {
L[i] <- L[i] + add
add <- stats::runif(1, 0.1, 0.5)
R[i] <- R[i] + add
check <- (L[i] <= tempo[i] & tempo[i] < R[i])
}
}
}
dados <- data.frame(L, R, tempo, delta)
return(dados)
}
dados.int = sim.IC(n = tamanho.amostral, lambda.param = lambdas, grid.vector = grid,
alpha.param = alpha,
lambda.cens.param = lambda.cens)
prop.table(table(dados.int$delta))
head(dados.int)
loglik.int = function(par, time.r, time.l,
grid,
delta){
b = length(grid) + 1 ## numero de intervalos
hazards = par[1:b] ## taxas de falha para os b intervalos
exp = par[b + 1] ## parametro de potencia
like = rep(0, length(delta))  ## armazenamento de informacao da verossimilhanca
## informacoes exponencial por partes Potencia (PPE) para esquerda
s0.tl = PPE(time = time.l[delta==1], cuts = grid, levels = hazards, alpha = exp, type = "survival")
## informacoes exponencial por partes Potencia (PPE) para direita
s0.tr = PPE(time = time.r[delta==1], cuts = grid, levels = hazards, alpha = exp, type = "survival")
like[delta==1] = (s0.tl - s0.tr)
## contribuicao da censura
s0.tl = PPE(time = time.l[delta==0], cuts = grid, levels = hazards, alpha = exp, type = "survival")
like[delta==0] = s0.tl
log.vero = sum(log(like))
return(-1*log.vero)
}
## escolha dos grids, com tempos observaveis
grid = time.grid.interval(li = dados.int$L, ri = dados.int$R,
type = "OBS", bmax = length(lambdas))
grid = grid[-c(1, length(grid))]
grid2 = c(0.4, 0.7, 1.1)
## estudo dos grids
table(cut(dados.int$L,c(0.3, 0.8, 1.2))) ## com os grids parametros reais
table(cut(dados.int$L,grid)) ## com os grids estimados pela observacao
table(cut(dados.int$L,grid2)) ## com os grids estimados pela observacao
table(cut(dados.int$R,c(0.3, 0.8, 1.2))) ## com os grids parametros reais
table(cut(dados.int$R,grid)) ## com os grids estimados pela observacao
table(cut(dados.int$R,grid2)) ## com os grids estimados pela observacao
chutes = c(rep(0.5,length(grid)+1),1.3)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l = dados.int$L,
time.r = dados.int$R,
grid = c(0.3, 0.8, 1.2),
delta = dados.int$delta)
estimacao.intervalar$par
c(lambdas, alpha)
set.seed(10)
tamanho.amostral = 3000
lambdas = c(1.3, 0.9, 1.2, 1.2)
alpha = 1.7
particoes = c(0.3, 0.6, 0.9)
x1 = rnorm(n = tamanho.amostral, mean = 0, sd = 1) ## Normal, continua
x2 = rbinom(n = tamanho.amostral, size = 1, prob = 0.5) ## Bernoulli, discreta
x.matriz = as.matrix(cbind(x1, x2))
betas = c(2.2, 0.5)
lambda.cens = 0.25
dados.int = sim.ICdata(n = tamanho.amostral, lambda.param = lambdas, grid.vector = particoes,
alpha.param = alpha, x.matrix = x.matriz, beta.param = betas,
lambda.cens.param = lambda.cens)
prop.table(table(dados.int$delta))
head(dados.int)
loglik.int = function(par, time.r, time.l,
grid,
delta, x.matrix){
b = length(grid) + 1 ## numero de intervalos
hazards = par[1:b] ## taxas de falha para os b intervalos
exp = par[b + 1] ## parametro de potencia
n.covars = dim(x.matrix)[2] ## numero de covariaveis
betas = par[(b + 2):(b + 1 + n.covars)]
like = rep(0, dim(x.matrix)[1])  ## armazenamento de informacao da verossimilhanca
## informacoes exponencial por partes Potencia (PPE) para esquerda
s0.tl = PPE(time = time.l[delta==1], cuts = grid, levels = hazards, alpha = exp, type = "survival")
## informacoes exponencial por partes Potencia (PPE) para direita
s0.tr = PPE(time = time.r[delta==1], cuts = grid, levels = hazards, alpha = exp, type = "survival")
## contribuicao do evento
sl = s0.tl^(exp(x.matrix[delta==1,] %*% betas))
sr = s0.tr^(exp(x.matrix[delta==1,] %*% betas))
like[delta==1] = (sl - sr)
## contribuicao da censura
s0.tl = PPE(time = time.l[delta==0], cuts = grid, levels = hazards, alpha = exp, type = "survival")
sl = s0.tl^(exp(x.matrix[delta==0,] %*% betas))
like[delta==0] = sl
log.vero = sum(log(like))
return(-1*log.vero)
}
head(dados.int)
grid = time.grid.interval(li = dados.int$L, ri = dados.int$R,
type = "OBS", bmax = length(lambdas))
grid = grid[-c(1, length(grid))]
chutes = c(rep(1,length(grid)+1),1, 1, 0.8)
## Metodo numerico BFGS
estimacao.int.cox = optim(par = chutes,
fn = loglik.int,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l = dados.int$L,
time.r = dados.int$R,
grid = grid ,
delta = dados.int$delta,
x.matrix = cbind(dados.int$x1, dados.int$x2))
estimacao.int.cox$par
Tht = c(lambdas, alpha, betas)
cbind(Tht, estimacao.int.cox$par)
source("C:/Users/NetoDavi/Desktop/survival_pibic/supervisor_functions.r")
if(!require(pacman)) install.packages("pacman"); library(pacman)
source("C:/Users/NetoDavi/Desktop/survival_pibic/supervisor_functions.r")
if(!require(pacman)) install.packages("pacman"); library(pacman)
p_load(icenReg)
#setwd('C:\\Users\\Dionisio\\Desktop\\Dionisio_Neto\\PIBIC_Survival_Analysis\\dados_para_teste')
setwd("C:/Users/NetoDavi/Desktop/survival_pibic/dados_para_teste")
## hemofilia_icens
breast = read.table('breast.txt', header = T)
dim(breast)
head(breast)
breast$right = ifelse(is.na(breast$right), Inf, breast$right)
turnbull_fit_breast = ic_np(cbind(left, right)~0, data = breast)
plot(turnbull_fit_breast)
weibull.breast = ic_par(formula = cbind(left, right) ~ ther, data = breast,
model = "ph", dist = "weibull")
plot(turnbull_fit_breast)
breast$left = breast$left + 0.0000010
breast$right = breast$right + 0.0000011
breast$right = ifelse(is.na(breast$right), Inf, breast$right)
turnbull_fit_breast = ic_np(cbind(left, right)~0, data = breast)
plot(turnbull_fit_breast)
breast = read.table('breast.txt', header = T)
dim(breast)
head(breast)
breast$right = ifelse(is.na(breast$right), Inf, breast$right)
turnbull_fit_breast = ic_np(cbind(left, right)~0, data = breast)
plot(turnbull_fit_breast)
breast = read.table('breast.txt', header = T)
dim(breast)
head(breast)
breast$left = breast$left + 0.0000010
breast$right = breast$right + 0.0000011
breast$right = ifelse(is.na(breast$right), Inf, breast$right)
turnbull_fit_breast = ic_np(cbind(left, right)~0, data = breast)
plot(turnbull_fit_breast)
weibull.breast = ic_par(formula = cbind(left, right) ~ ther, data = breast,
model = "ph", dist = "weibull")
weibull.breast$coefficients
plot(weibull.breast)
breast = read.table('breast.txt', header = T)
dim(breast)
head(breast)
breast$right = ifelse(is.na(breast$right), Inf, breast$right)
n.intervalos = 15
for (int in 2:15){
n.intervalos = int
chute = c(rep(0.1,n.intervalos),
0.8,
1.2,0.1,
0.1)
mepp.tent.breast = fit.mepp.cf(L = breast$left, R = breast$right, n.int = n.intervalos,
cov.risco = cbind(breast$ther),
cov.cura = cbind(1, breast$ther),
start = chute)
aic = AIC.surv(loglik = mepp.tent.breast$loglik,
n.param = length(mepp.tent.breast$estimated))
bic = BIC.surv(loglik = mepp.tent.breast$loglik,
n.param = length(mepp.tent.breast$estimated),
n.sample = dim(breast)[1])
hc = HC.surv(loglik = mepp.tent.breast$loglik,
n.param = length(mepp.tent.breast$estimated),
n.sample = dim(breast)[1])
print(paste("n intervalo", int))
print(paste("AIC: ", aic))
print(paste("BIC: ", bic))
print(paste("HC: ", hc))
}
fit.mepp.cf
source("C:/Users/NetoDavi/Desktop/survival_pibic/supervisor_functions.r")
loglikIC
fit.mepp.cf = function(L, R, n.int, cov.risco, cov.cura, start){
## extracao do grid observado
grid.obs=time.grid.interval(li=L, ri=R, type="OBS", bmax= n.int)
grid.obs=grid.obs[-c(1, length(grid.obs))]
est <- optim(par = start, fn=loglikIC, gr = NULL, method = "BFGS",
control=list(fnscale=-1), hessian = TRUE, l=L,
r=R, x.cure=cov.cura, x.risk=cov.risco, grid.vet=grid.obs)
estimated = est$par
hessian = est$hessian
loglik = est$value
results = list(estimated = estimated, hessian = hessian, loglik = loglik)
return(results)
}
n.intervalos = 15
for (int in 2:15){
n.intervalos = int
chute = c(rep(0.1,n.intervalos),
0.8,
1.2,0.1,
0.1)
mepp.tent.breast = fit.mepp.cf(L = breast$left, R = breast$right, n.int = n.intervalos,
cov.risco = cbind(breast$ther),
cov.cura = cbind(1, breast$ther),
start = chute)
aic = AIC.surv(loglik = mepp.tent.breast$loglik,
n.param = length(mepp.tent.breast$estimated))
bic = BIC.surv(loglik = mepp.tent.breast$loglik,
n.param = length(mepp.tent.breast$estimated),
n.sample = dim(breast)[1])
hc = HC.surv(loglik = mepp.tent.breast$loglik,
n.param = length(mepp.tent.breast$estimated),
n.sample = dim(breast)[1])
print(paste("n intervalo", int))
print(paste("AIC: ", aic))
print(paste("BIC: ", bic))
print(paste("HC: ", hc))
}
library(eha)
n.intervalos = 15
for (int in 2:15){
n.intervalos = int
chute = c(rep(0.1,n.intervalos),
0.8,
1.2,0.1,
0.1)
mepp.tent.breast = fit.mepp.cf(L = breast$left, R = breast$right, n.int = n.intervalos,
cov.risco = cbind(breast$ther),
cov.cura = cbind(1, breast$ther),
start = chute)
aic = AIC.surv(loglik = mepp.tent.breast$loglik,
n.param = length(mepp.tent.breast$estimated))
bic = BIC.surv(loglik = mepp.tent.breast$loglik,
n.param = length(mepp.tent.breast$estimated),
n.sample = dim(breast)[1])
hc = HC.surv(loglik = mepp.tent.breast$loglik,
n.param = length(mepp.tent.breast$estimated),
n.sample = dim(breast)[1])
print(paste("n intervalo", int))
print(paste("AIC: ", aic))
print(paste("BIC: ", bic))
print(paste("HC: ", hc))
}
n.intervalos = 2
chute = c(rep(0.1,n.intervalos),
0.8,
1.2,0.1,
0.1)
mepp.tent.breast = fit.mepp.cf(L = breast$left, R = breast$right, n.int = n.intervalos,
cov.risco = cbind(breast$ther),
cov.cura = cbind(1, breast$ther),
start = chute)
parametros = mepp.tent.breast$estimated
parametros
n.int+dim(breast$ther)[2]
n.int+dim(breast$ther)[2]
n.intervalos+dim(breast$ther)[2]
n.intervalos+1+1+1
parametros[n.intervalos+5]
parametros[1:n.intervalos]
parametros[n.intervalos+1]
parametros[(n.intervalos+2):(n.intervalos+4)]
parametros[(n.intervalos+2):(n.intervalos+3)]
parametros[n.intervalos+4]
n.intervalos
parametros
grid.obs.breast=time.grid.interval(li=breast$left, ri=breast$right, type="OBS", bmax= n.intervalos)
grid.obs.breast=grid.obs[-c(1, length(grid.obs.breast))]
grid.obs.breast=time.grid.interval(li=breast$left, ri=breast$right, type="OBS", bmax= n.intervalos)
grid.obs.breast=grid.obs.breast[-c(1, length(grid.obs.breast))]
grid.obs.breast
n.intervalos
spop_mepp_l = SpopMEPP(t = breast$left, lambda.par = lambdas.est.breast, alpha.par = alpha.est.breast,
theta.par = b.est.breast, beta.par = betas.est.breast,
x.cure = cbind(1, breast$ther), x.risk = cbind(breast$ther),
grid.vet = grid.obs.breast)
parametros = mepp.tent.breast$estimated
lambdas.est.breast = parametros[1:n.intervalos]
alpha.est.breast = parametros[n.intervalos+1]
b.est.breast = parametros[(n.intervalos+2):(n.intervalos+3)]
betas.est.breast = parametros[n.intervalos+4]
grid.obs.breast=time.grid.interval(li=breast$left, ri=breast$right, type="OBS", bmax= n.intervalos)
grid.obs.breast=grid.obs.breast[-c(1, length(grid.obs.breast))]
spop_mepp_l = SpopMEPP(t = breast$left, lambda.par = lambdas.est.breast, alpha.par = alpha.est.breast,
theta.par = b.est.breast, beta.par = betas.est.breast,
x.cure = cbind(1, breast$ther), x.risk = cbind(breast$ther),
grid.vet = grid.obs.breast)
spop_mepp_l
spop_mepp_l = SpopMEPP(t = breast$left, lambda.par = lambdas.est.breast, alpha.par = alpha.est.breast,
theta.par = b.est.breast, beta.par = betas.est.breast,
x.cure = cbind(1, breast$ther), x.risk = cbind(breast$ther),
grid.vet = grid.obs.breast)
spop_mepp_l = SpopMEPP(t = breast$right, lambda.par = lambdas.est.breast, alpha.par = alpha.est.breast,
theta.par = b.est.breast, beta.par = betas.est.breast,
x.cure = cbind(1, breast$ther), x.risk = cbind(breast$ther),
grid.vet = grid.obs.breast)
spop_mepp_l = SpopMEPP(t = breast$left, lambda.par = lambdas.est.breast, alpha.par = alpha.est.breast,
theta.par = b.est.breast, beta.par = betas.est.breast,
x.cure = cbind(1, breast$ther), x.risk = cbind(breast$ther),
grid.vet = grid.obs.breast)
spop_mepp_r = SpopMEPP(t = breast$right, lambda.par = lambdas.est.breast, alpha.par = alpha.est.breast,
theta.par = b.est.breast, beta.par = betas.est.breast,
x.cure = cbind(1, breast$ther), x.risk = cbind(breast$ther),
grid.vet = grid.obs.breast)
rm.breast = (spop_mepp_l*log(spop_mepp_l) - spop_mepp_r*log(spop_mepp_r))/(spop_mepp_l-spop_mepp_r)
summary(rm.breast)
boxplot(rm.breast)
boxplot(rm.breast)
sign(rm.breast)
r.Deviance.breast  = sign(rm.breast)*(-2*(rm.breast+log(rm.breast)))^(0.5)
r.Deviance.breast
log(rm.breast)
rm.breast
rm.breast
hist(rm.breast)
mean(rm.breast)
sign(rm.breast)*(-2*(rm.breast+log(rm.breast)))^(0.5)
mean(r.Deviance.breast,na.rm=T)
hist(r.Deviance.breast)
