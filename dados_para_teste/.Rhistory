C <- pmin(A, B*rexp(n, rate=lambda.parc))
#-- Generating the survival times:
t     <- rep(0,n) # tempos de falha
t_obs <- rep(0,n)
delta <- rep(0,n)
for(i in 1:n){
if(Y[i]==1){
t[i] <- gen.mepp(lambda.par=lambda.par, alpha.par=alpha.par, grid.vet=grid.vet, beta.par=beta.par, x.mat=X[i,])
#t[i] <- gen.mepp(lambda.par=lambda.par, alpha.par=alpha.par, grid.vet=grid.vet, beta.par=beta.par, x.mat=0)
if(t[i]<C[i]){
t_obs[i] <- t[i]
delta[i] <- 1
}else{
t_obs[i] <- C[i]
}
}else{
t[i] <- C[i]
t_obs[i] <- t[i]
}
}
tempo <- t_obs
#-- Observed times:
delta <- ifelse(t < C, 1, 0)
L <- R <- tempo * NA
for (i in 1:n) {
if (delta[i] == 0) {
L[i] <- tempo[i]
R[i] <- Inf
}
else {
L[i] <- 0
add <- stats::runif(1, 0.1, 0.5)
R[i] <- add
check <- (L[i] <= tempo[i] & tempo[i] < R[i])
while (!check) {
L[i] <- L[i] + add
add <- stats::runif(1, 0.1, 0.5)
R[i] <- R[i] + add
check <- (L[i] <= tempo[i] & tempo[i] < R[i])
}
}
}
dados <- data.frame(L, R, tempo, Y, delta, xi1, xi2)
return(dados)
}
SpopMEPP <- function(t=t, lambda.par=lambda.par, alpha.par=alpha.par, grid.vet=grid.vet, beta.par=beta.par, theta.par=theta.par, x.cure=x.cure, x.risk=x.risk){
# t          <- dadosIC$tempo
# lambda.par <- lambda.f
# alpha.par  <- alpha.f
# grid.vet   <- grid.time
# beta.par   <- beta.f
# theta.par  <- beta.c
# x.cure     <- x.c
# x.risk     <- x.f
S_MEPP <- as.numeric(exp(-cal_Ht_MEPP(time.obs=t, lambda.par=lambda.par, alpha.par=alpha.par, grid.vet=grid.vet)*exp(x.risk%*%beta.par)))
elinpred <- as.numeric(exp(1*(x.cure%*%theta.par)))
probY    <- 1/(1+elinpred)
spop     <- probY+(1-probY)*S_MEPP
return(spop)
}
loglikIC <- function(a, l=l, r=r, x.cure=x.cure, x.risk=x.risk, grid.vet=grid.vet){
# lambda.par  = c(1.1, 0.8, 0.5)
# alpha.par   = 0.8
# grid.vet    = c(0.5, 2)
# beta.par    = c(-0.5, 0.5)
# theta.par   = c(1, 0.5, 0)
#
#
#
# l      <- dadosIC$L
# r      <- dadosIC$R
# x.cure <- cbind(1, x1=dadosIC$xi1, x2=dadosIC$xi2)
# x.risk <- cbind(x1=dadosIC$xi1, x2=dadosIC$xi2)
#
# a<- c(lambda.par, alpha.par, theta.par,  beta.par)
#
#a <- 1:length(param)
npar <- length(a)
b <- length(grid.vet)+1
hazards = a[1:b] ## taxas de falha para os b intervalos
alpha = a[b + 1] ## parametro de potencia
n.cov.cure = dim(x.cure)[2] ## numero de covariaveis com fracao de cura, para risco tiramos um (beta0)
n.cov.risk = dim(x.risk)[2] ## numero de covariaveis com fracao de cura, para risco tiramos um (beta0)
betas.cure = a[(b + 2):(b + 1 + n.cov.cure)]
betas.risk = a[(b + 5):(b + 4 + n.cov.risk)]
n.sample <- nrow(x.cure)
cens <- ifelse(is.finite(r), 1, 0)
lik <- rep(0, n.sample)
p2 <- SpopMEPP(t=l[cens==1], lambda.par=hazards, alpha.par=alpha, grid.vet=grid.vet, beta.par=betas.risk, theta.par=betas.cure, x.cure=x.cure[cens==1,], x.risk=x.risk[cens==1,])
p1 <- SpopMEPP(t=r[cens==1], lambda.par=hazards, alpha.par=alpha, grid.vet=grid.vet, beta.par=betas.risk, theta.par=betas.cure, x.cure=x.cure[cens==1,], x.risk=x.risk[cens==1,])
lik[cens==1] <- p2-p1
p1 <- SpopMEPP(t=l[cens==0], lambda.par=hazards, alpha.par=alpha, grid.vet=grid.vet, beta.par=betas.risk, theta.par=betas.cure, x.cure=x.cure[cens==0,], x.risk=x.risk[cens==0,])
lik[cens==0] <- p1
return(sum(log(lik)))
}
loglikIC2 <- function(a, l=l, r=r, x.cure=x.cure, grid.vet=grid.vet){
# lambda.par  = c(1.1, 0.8, 0.5)
# alpha.par   = 0.8
# grid.vet    = c(0.5, 2)
# beta.par    = c(-0.5, 0.5)
# theta.par   = c(1, 0.5, 0)
#
#
#
# l      <- dadosIC$L
# r      <- dadosIC$R
# x.cure <- cbind(1, x1=dadosIC$xi1, x2=dadosIC$xi2)
# x.risk <- cbind(x1=dadosIC$xi1, x2=dadosIC$xi2)
#
# a<- c(lambda.par, alpha.par, theta.par,  beta.par)
#
#a <- 1:length(param)
npar <- length(a)
b <- length(grid.vet)+1
hazards = a[1:b] ## taxas de falha para os b intervalos
alpha = a[b + 1] ## parametro de potencia
n.cov.cure = dim(x.cure)[2] ## numero de covariaveis com fracao de cura, para risco tiramos um (beta0)
#n.cov.risk = dim(x.risk)[2] ## numero de covariaveis com fracao de cura, para risco tiramos um (beta0)
betas.cure = a[(b + 2):(b + 1 + n.cov.cure)]
#betas.cure = a[(b + 5):(b + 4 + n.cov.cure)]
betas.risk <- 0
n.sample <- nrow(x.cure)
cens <- ifelse(is.finite(r), 1, 0)
lik <- rep(0, n.sample)
p2 <- SpopMEPP(t=l[cens==1], lambda.par=hazards, alpha.par=alpha, grid.vet=grid.vet, beta.par=betas.risk, theta.par=betas.cure, x.cure=x.cure[cens==1,], x.risk=0)
p1 <- SpopMEPP(t=r[cens==1], lambda.par=hazards, alpha.par=alpha, grid.vet=grid.vet, beta.par=betas.risk, theta.par=betas.cure, x.cure=x.cure[cens==1,], x.risk=0)
lik[cens==1] <- p2-p1
p1 <- SpopMEPP(t=l[cens==0], lambda.par=hazards, alpha.par=alpha, grid.vet=grid.vet, beta.par=betas.risk, theta.par=betas.cure, x.cure=x.cure[cens==0,], x.risk=0)
lik[cens==0] <- p1
return(sum(log(lik)))
}
# testando o modelo:
library(eha)
n <- 100 # Tamanho amostral
#--- Par?metros falha:
alpha.f   <- 0.8
lambda.f  <- c(1.1, 0.8, 0.5)
n.intervals <- length(lambda.f)
grid.time <- c(0.5, 2)
beta.f    <- c(-0.5, 0.5)
#beta.f    <- 0
beta.c    <- c(1, 0.5, -0.5)
lambda.c <- 1
Theta = c(lambda.f, alpha.f,beta.c,beta.f)
# Ajuste usando os intervalos de tempo:
ini.info <- c(lambda.f, alpha.f, beta.c,  beta.f)
npar <- length(c(lambda.f, alpha.f,beta.c, beta.f))
samp <- 100
est  <- matrix(NA, ncol=npar, nrow=samp)
matrix.ep = matrix(data = 0, nrow = samp,
ncol = length(Theta))
for(i in 1:samp){
dadosIC <- sim.std.cure.ICdata(n=n, lambda.par=lambda.f, alpha.par=alpha.f,
grid.vet=grid.time, beta.par= beta.f, lambda.parc=lambda.c,
theta.par = beta.c , A = 5, B = 15)
x.f <- cbind(x1=dadosIC$xi1, x2=dadosIC$xi2)
x.c <- cbind(1, x1=dadosIC$xi1, x2=dadosIC$xi2)
grid.obs=time.grid.interval(li=dadosIC$L, ri=dadosIC$R, type="OBS", bmax=length(lambda.f ))
grid.obs=grid.obs[-c(1, length(grid.obs))]
chutes = c(rep(0.1, length(lambda.f)), 1, 1, 0.5, 0.5, 0.5, 0.5)
test <- optim(par = chutes, fn=loglikIC, gr = NULL, method = "BFGS",
control=list(fnscale=-1), hessian = TRUE, l=dadosIC$L,
r=dadosIC$R, x.cure=x.c, x.risk=x.f, grid.vet=grid.obs)
# ini.info <- c(lambda.f, alpha.f, beta.c)
# test <- optim(par = ini.info, fn=loglikIC2, gr = NULL, method = "BFGS",
#               control=list(fnscale=-1), hessian = TRUE, l=dadosIC$L,
#               r=dadosIC$R, x.cure=x.c, grid.vet=grid.time)
# test$par
matrix.ep[i,] = sqrt(diag(solve(-test$hessian)))
est[i,] <- test$par
cat("Iter=", i, "\n")
}
myfunc <- function(z) {
x <- z[1]
y <- z[2]
(4*x^2-20* x + 1/4*y^2 + 8)^2 + (1/2 * x*y^2 + 2*x- 5*y + 8)^2
}
optim(c(0, 0), myfunc)
eq = function(theta){
equacao = (2 + 2*theta + theta^2) - (1.5/exp(-x))
return(equacao)
}
optim(c(0), eq)
sol = optim(c(0), eq)
optimize(eq)
optimize(eq, interval = c(0,1))
eq = function(theta){
equacao = (2 + 2*theta + theta^2) - (1.5/exp(-x))
return(equacao)
}
optimize(eq, interval = c(0,1))
eq = function(theta){
equacao = (2 + 2*theta + theta^2) - (1.5/exp(-x))
return(equacao)
}
optimize(eq, interval = c(0,1))
eq = function(theta){
equacao = (2 + 2*theta + theta^2) - (1.5/exp(-x))
return(equacao)
}
solucao <- uniroot(eq, interval = c(0, 1))
eq = function(theta){
equacao = (2 + 2*theta + theta^2) - (1.5/exp(-theta))
return(equacao)
}
solucao <- uniroot(eq, interval = c(0, 1))
eq = function(theta){
equacao = (2 + 2*theta + theta^2) - (1.5/exp(-theta))
return(equacao)
}
solucao <- uniroot(eq, interval = c(-1, 1))
solucao <- uniroot(eq, interval = c(0, 1))
solucao <- uniroot(eq, interval = c(0, 1),
start = 0.2)
solucao <- uniroot(eq, interval = c(0, 1))
equacao <- function(x) {
x^2 - 3*x + 2  # Exemplo: x^2 - 3x + 2 = 0
}
# Fornecer um palpite inicial próximo da raiz
palpite_inicial <- 1
# Encontrar a raiz da equação usando a função uniroot() com o palpite inicial
solucao <- uniroot(equacao, interval = c(-1, 1), start = palpite_inicial)
equacao <- function(x) {
x^2 - 3*x + 2  # Exemplo: x^2 - 3x + 2 = 0
}
# Fornecer um palpite inicial próximo da raiz
palpite_inicial <- 1
# Encontrar a raiz da equação usando a função uniroot() com o palpite inicial
solucao <- uniroot(equacao, interval = c(-1, 1))
# Acessar o valor da solução
valor_solucao <- solucao$root
valor_solucao
eq = function(theta){
equacao = (2 + 2*theta + theta^2) - (1.5/exp(-theta))
return(equacao)
}
solucao <- uniroot(eq, interval = c(0, 1))
solucao <- uniroot(f = eq, interval = c(0, 1))
curve(eq, from = 0, to = 1)
uniroot(eq, lower = 0, upper = 1)
uniroot(eq, lower = -10, upper = 10)
uniroot(eq, lower = -10, upper = 5)
curve(eq, from = 0, to = 5)
curve(eq, from = -5, to = 5)
abline(h = 0, lty = 3)
curve(eq, from = -2, to = 2)
abline(h = 0, lty = 3)
curve(eq, from = -10, to = 10)
abline(h = 0, lty = 3)
eq2 = function(theta){
equacao = exp(-theta) + theta*exp(-theta) - 0.85
return(equacao)
}
curve(eq2, from = -10, to = 10)
curve(eq2, from = -1, to = 5)
abline(h = 0, lty = 3)
uniroot(eq2, lower = -1, upper = 5)
eq2 = function(theta){
equacao = exp(-theta) + theta*exp(-theta) - 0.85
return(equacao)
}
curve(eq2, from = -1, to = 5)
abline(h = 0, lty = 3)
uniroot(eq2, lower = -1, upper = 5)
uniroot(eq2, lower = -10, upper = 5)
uniroot(eq2, lower = -10, upper = 10)
uniroot(eq2, lower = -1, upper = 1)
eq2
eq2 = function(theta){
equacao = exp(-theta) + theta*exp(-theta) - 0.85
return(equacao)
}
curve(eq2, from = -1, to = 5)
abline(h = 0, lty = 3)
uniroot(eq2, lower = -1, upper = 1)
curve(eq2, from = -100, to = 500)
abline(h = 0, lty = 3)
uniroot(eq2, lower = -1, upper = 1)
curve(eq2, from = -1000, to = 1000)
abline(h = 0, lty = 3)
uniroot(eq2, lower = -1000, upper =  1000)
uniroot(eq2, lower = -100, upper =  100)
uniroot(eq2, lower = 0, upper =  100)
uniroot(eq2, lower = 0, upper =  10)
setwd('C:\\Users\\NetoDavi\\Desktop\\survival_pibic\\dados_para_teste')
## hemofilia_icens
hemo.icens = read.fwf('hemofilia_icens.txt')
## hemofilia_icens
hemo.icens = read.table('hemofilia_icens.txt')
hemo.icens
dim(hemo.icens)
## hemofilia_icens
hemo.icens = read.table('hemofilia_icens.txt', header = T)
dim(hemo.icens)
head(hemo.icens)
library(ReIns)
tempo.aval = seq(0,12,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = hemo.icens$L, R = hemo.icens$R,
censored = hemo.icens$cens)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,10,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = hemo.icens$L, R = hemo.icens$R,
censored = hemo.icens$cens)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,200,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = hemo.icens$L, R = hemo.icens$R,
censored = hemo.icens$cens)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,70,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = hemo.icens$L, R = hemo.icens$R,
censored = hemo.icens$cens)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
max(hemo.icens$R)
max(hemo.icens[cens == 1]$R)
max(hemo.icens[hemo.icens$cens == 1]$R)
hemo.icens[hemo.icens$cens == 1]
hemo.icens[hemo.icens$cens == 1,R]
hemo.icens[hemo.icens$cens == 1,"R"]
max(hemo.icens[hemo.icens$cens == 1,"R"])
tempo.aval = seq(0,50,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = hemo.icens$L, R = hemo.icens$R,
censored = hemo.icens$cens)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,20,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = hemo.icens$L, R = hemo.icens$R,
censored = hemo.icens$cens)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,2000,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = hemo.icens$L, R = hemo.icens$R,
censored = hemo.icens$cens)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,200,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = hemo.icens$L, R = hemo.icens$R,
censored = hemo.icens$cens)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,100,0.1)
trnb.fit = Turnbull(x = tempo.aval, L = hemo.icens$L, R = hemo.icens$R,
censored = hemo.icens$cens)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
smoke2009 = read.table('smoke_cessation_Bannerge2009.txt', header = T)
dim(smoke2009)
head(smoke2009)
delta = ifelse(smoke2009$Timept2 == Inf, 0, 1)
delta = ifelse(smoke2009$Timept2 == Inf, 0, 1)
trnb.fit.smoke2009 = Turnbull(x = tempo.aval, L = smoke2009$Timept1, R = smoke2009$Timept2,
censored = delta)
plot(tempo.aval, trnb.fit$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
plot(tempo.aval, trnb.fit.smoke2009$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
delta = ifelse(smoke2009$Timept2 == Inf, 0, 10)
delta = ifelse(smoke2009$Timept2 == Inf, 0, 10)
trnb.fit.smoke2009 = Turnbull(x = tempo.aval, L = smoke2009$Timept1, R = smoke2009$Timept2,
censored = delta)
plot(tempo.aval, trnb.fit.smoke2009$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,10,0.1)
delta = ifelse(smoke2009$Timept2 == Inf, 0, 1)
trnb.fit.smoke2009 = Turnbull(x = tempo.aval, L = smoke2009$Timept1, R = smoke2009$Timept2,
censored = delta)
plot(tempo.aval, trnb.fit.smoke2009$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,4,0.1)
delta = ifelse(smoke2009$Timept2 == Inf, 0, 1)
trnb.fit.smoke2009 = Turnbull(x = tempo.aval, L = smoke2009$Timept1, R = smoke2009$Timept2,
censored = delta)
plot(tempo.aval, trnb.fit.smoke2009$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,2,0.1)
delta = ifelse(smoke2009$Timept2 == Inf, 0, 1)
trnb.fit.smoke2009 = Turnbull(x = tempo.aval, L = smoke2009$Timept1, R = smoke2009$Timept2,
censored = delta)
plot(tempo.aval, trnb.fit.smoke2009$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
tempo.aval = seq(0,10,0.1)
delta = ifelse(smoke2009$Timept2 == Inf, 0, 1)
trnb.fit.smoke2009 = Turnbull(x = tempo.aval, L = smoke2009$Timept1, R = smoke2009$Timept2,
censored = delta)
plot(tempo.aval, trnb.fit.smoke2009$surv, type = "s",
ylab = "Estimador de Turnbull para S(t)")
install.packages("inteval")
install.packages("interval")
install.packages("interval")
library(interval)
npmle_fit <- ic_np(cbind(Timept1, Timept2) ~ 0, data = smoke2009)
library(interval)
npmle_fit <- ic_np(cbind(Timept1, Timept2) ~ 0, data = smoke2009)
interval::
install.packages("icenReg")
library(icenReg)
npmle_fit <- ic_np(cbind(Timept1, Timept2) ~ 0, data = smoke2009)
plot(fit)
plot(npmle_fit)
npmle_fit <- ic_np(cbind(Timept1, Timept2) ~ 0, data = smoke2009)
plot(npmle_fit)
p_load(icenReg)
turnbull_fit = ic_np(cbind(L, R)~1, data = hemo.icens)
plot(turnbull_fit)
dim(hemo.icens)
head(hemo.icens)
turnbull_fit = ic_np(cbind(L, R)~1, data = hemo.icens)
plot(turnbull_fit)
turnbull_fit = ic_np(cbind(L, R)~1, data = hemo.icens)
plot(turnbull_fit)
turnbull_fit = ic_np(cbind(L, R)~0, data = hemo.icens)
plot(turnbull_fit)
smoke2009 = read.table('smoke_cessation_Bannerge2009.txt', header = T)
dim(smoke2009)
head(smoke2009)
tempo.aval = seq(0,10,0.1)
delta = ifelse(smoke2009$Timept2 == Inf, 0, 1)
npmle_fit <- ic_np(cbind(Timept1, Timept2) ~ 0, data = smoke2009)
plot(npmle_fit)
npmle_fit <- ic_np(cbind(Timept1, Timept2) ~ 0, data = smoke2009)
plot(npmle_fit)
plot(npmle_fit)
plot(turnbull_fit)
head(hemo.icens)
turnbull_fit = ic_np(cbind(L, R)~Low, data = hemo.icens)
plot(turnbull_fit)
turnbull_fit = ic_sp(cbind(L, R)~Low, data = hemo.icens)
plot(turnbull_fit)
turnbull_fit = ic_sp(cbind(L, R), data = hemo.icens)
plot(turnbull_fit)
turnbull_fit = ic_cp(cbind(L, R), data = hemo.icens)
plot(turnbull_fit)
turnbull_fit$trace
turnbull_fit$bsMat
turnbull_fit$coefficients
turnbull_fit$trace
plot(turnbull_fit)
turnbull_fit = ic_cp(cbind(L, R), data = hemo.icens, model = 'po')
turnbull_fit = ic_sp(cbind(L, R), data = hemo.icens, model = 'po')
if(!require(pacman)) install.packages("pacman"); library(pacman)
p_load(icenReg)
setwd('C:\\Users\\NetoDavi\\Desktop\\survival_pibic\\dados_para_teste')
## hemofilia_icens
hemo.icens = read.table('hemofilia_icens.txt', header = T)
dim(hemo.icens)
head(hemo.icens)
turnbull_fit = ic_sp(cbind(L, R), data = hemo.icens, model = 'po')
hemo.icens
turnbull_fit = ic_sp(cbind(L, R), data = hemo.icens)
turnbull_fit = ic_sp(cbind(L, R), data = hemo.icens)
turnbull_fit = ic_sp(cbind(hemo.icens$L,hemo.icens$R), data = hemo.icens)
turnbull_fit = ic_cp(cbind(L, R)~0, data = hemo.icens, model= 'po')
turnbull_fit = ic_sp(cbind(L, R)~0, data = hemo.icens, model= 'po')
plot(turnbull_fit)
turnbull_fit = ic_sp(cbind(L, R)~0, data = hemo.icens, model= 'po')
plot(turnbull_fit)
turnbull_fit = ic_sp(cbind(L, R)~0, data = hemo.icens, model= 'ph')
plot(turnbull_fit)
turnbull_fit = ic_np(cbind(L, R)~0, data = hemo.icens, model= 'ph')
turnbull_fit = ic_np(cbind(L, R)~0, data = hemo.icens)
plot(turnbull_fit)
smoke2009 = read.table('smoke_cessation_Bannerge2009.txt', header = T)
dim(smoke2009)
head(smoke2009)
tempo.aval = seq(0,10,0.1)
delta = ifelse(smoke2009$Timept2 == Inf, 0, 1)
npmle_fit <- ic_np(cbind(Timept1, Timept2) ~ 0, data = smoke2009)
plot(npmle_fit)
colnames(hemo.icens)
head(hemo.icens)
weibull = ic_par(formula = cbind(L, R) ~ High, data = hemo.icens,
model = "ph", dist = "weibull")
plot(weibull)
plot(turnbull_fit)
plot(weibull)
weibull = ic_par(formula = cbind(L, R) ~ High, data = hemo.icens,
model = "po", dist = "weibull")
plot(weibull)
weibull = ic_par(formula = cbind(L, R) ~ High, data = hemo.icens,
model = "ph", dist = "weibull")
plot(weibull)
weibull$coefficients
AIC.surv = function(loglik, n.param) {
aic_formula = 2*(n.param - loglik)
return(aic_formula)
}
BIC.surv = function(loglik, n.param, n.sample){
bayes_criterion = -2*loglik + (log(n.sample) * n.param)
return(bayes_criterion)
}
HC.surv = function(loglik, n.param, n.sample){
hc_criterion = -2*(loglik) + (2*n.param*log(log(n.sample)))
return(hc_criterion)
}
weibull$llk
AIC.surv(loglik = weibull$llk, n.param = 3)
BIC.surv = function(loglik, n.param, n.sample){
bayes_criterion = -2*loglik + (log(n.sample) * n.param)
return(bayes_criterion)
}
HC.surv = function(loglik, n.param, n.sample){
hc_criterion = -2*(loglik) + (2*n.param*log(log(n.sample)))
return(hc_criterion)
}
dim(hemo.icens)[1]
BIC.surv(loglik = weibull$llk, n.param = 3, n.sample = dim(hemo.icens)[1])
AIC.surv(loglik = weibull$llk, n.param = 3)
BIC.surv(loglik = weibull$llk, n.param = 3, n.sample = dim(hemo.icens)[1])
HC.surv(loglik = weibull$llk, n.param = 3,n.sample = dim(hemo.icens)[1])
