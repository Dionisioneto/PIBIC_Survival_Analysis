if(!require(pacman)) install.packages("pacman"); library(pacman)
p_load(eha, survival)
source
## ajustar o script com as funcoes de sobrevivencia
source('C:/Users/Dionisio/Desktop/Dionisio_Neto/PIBIC_Survival_Analysis/funcoes_sobrevivencia_pibic2023.R')
set.seed(10)
tamanho.amostral = 500
taxas.falha = c(0.2, 0.4, 0.95)
particoes = c(0.5, 0.9)
potencia = 1.3
beta = c(0.5, 2.3)
x1 = rnorm(n = tamanho.amostral, mean = 0, sd = 1)
x2 = rbinom(n = tamanho.amostral, size = 1, prob = 0.5)
x.matriz = as.matrix(cbind(x1, x2))
tempo.falha = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
tempo.censura = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
tempo = pmin(tempo.falha, tempo.censura)
delta = ifelse(tempo.falha <= tempo.censura, 1, 0)
grid = time.grid.obs.t(tempo, delta, n.int = 3)
grid = grid[-c(1, length(grid))]
chutes = c(rep(0.5,length(grid)+1),1,0.5,1)
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
taxas.falha
estimacao.teste.cox$par[1:3]
potencia
estimacao.teste.cox$par[4]
beta
estimacao.teste.cox$par[5:6]
estimacao.teste.cox$hessian
solve(-estimacao.teste.cox$hessian)
tempo.falha
tempo.censura = rexp(n = tamanho.amostral, rate = 0.9)
tempo.censura
tempo.falha
tempo.falha = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
tempo.censura = rexp(n = tamanho.amostral, rate = 0.9)
tempo = pmin(tempo.falha, tempo.censura)
delta = ifelse(tempo.falha <= tempo.censura, 1, 0)
grid = time.grid.obs.t(tempo, delta, n.int = 3)
grid = grid[-c(1, length(grid))]
chutes = c(rep(0.5,length(grid)+1),1,0.5,1)
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
taxas.falha
estimacao.teste.cox$par[1:3]
potencia
estimacao.teste.cox$par[4]
beta
estimacao.teste.cox$par[5:6]
solve(-estimacao.teste.cox$hessian)
tamanho.amostral = 4000
taxas.falha = c(0.2, 0.4, 0.95)
particoes = c(0.5, 0.9)
potencia = 1.3
beta = c(0.5, 2.3)
x1 = rnorm(n = tamanho.amostral, mean = 0, sd = 1)
x2 = rbinom(n = tamanho.amostral, size = 1, prob = 0.5)
x.matriz = as.matrix(cbind(x1, x2))
tempo.falha = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
tempo.censura = rexp(n = tamanho.amostral, rate = 0.9)
tempo = pmin(tempo.falha, tempo.censura)
delta = ifelse(tempo.falha <= tempo.censura, 1, 0)
grid = time.grid.obs.t(tempo, delta, n.int = 3)
grid = grid[-c(1, length(grid))]
chutes = c(rep(0.5,length(grid)+1),1,0.5,1)
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
solve(estimacao.teste.cox$hessian)
diag(solve(estimacao.teste.cox$hessian))
diag(solve(-estimacao.teste.cox$hessian))
diag(solve(estimacao.teste.cox$hessian))
set.seed(10)
## ajsutando a parametrizacao
tamanho.amostral = 600
## parametros do PPE
taxas.falha = c(0.2, 0.4, 0.65)
particoes = c(0.5, 0.9)
potencia = 1.4
beta = c(0.5, 2.3)
x1 = rnorm(n = tamanho.amostral, mean = 0, sd = 1)
x2 = rbinom(n = tamanho.amostral, size = 1, prob = 0.5)
x.matriz = as.matrix(cbind(x1, x2))
# numero de iteracoes a acontecer
n.iter = 50
