log.vero = log(sum(p1,p2))
return(-1*log.vero)
}
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(1.2,0.5,1.2)
betas.risco = c(0.5,0.3)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 100, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(1.2,0.5,0.3)
betas.risco = c(0.5,0.3)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 100, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
grid.obs = grid.obs[-c(1, length(grid))]
chutes = c(rep(0.1,length(grid)+1),1, 1.2, 0.3, 0.8, 0.5, 0.8)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
delta = dados$delta,
x.matriz = cbind(1,dados$X1, dados$X2))
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(1.2,0.5,0.3)
betas.risco = c(0.5,0.3)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 100, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
grid.obs = grid.obs[-c(1, length(grid))]
chutes = c(rep(0.4,length(grid)+1),1, 1.2, 0.3, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
delta = dados$delta,
x.matriz = cbind(1,dados$X1, dados$X2))
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
delta = dados$delta,
x.matriz = cbind(1,dados$X1, dados$X2))
chutes = c(rep(0.04,length(grid)+1),1, 1.2, 0.3, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
delta = dados$delta,
x.matriz = cbind(1,dados$X1, dados$X2))
chutes = c(rep(0.004,length(grid)+1),1, 1.2, 0.3, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
delta = dados$delta,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = F,
method = "Nelder-Mead",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
delta = dados$delta,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
chutes = c(rep(0.4,length(grid)+1),1, 1.2, 0.3, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
delta = dados$delta,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = F,
method = "Nelder-Mead",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
delta = dados$delta,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
loglik.int.fc = function(par, time.l, time.r,
grid, Yi, x.matriz){
b = length(grid) + 1 ## numero de intervalos
hazards = par[1:b] ## taxas de falha para os b intervalos
exp = par[b + 1] ## parametro de potencia
n.covars = dim(x.matriz)[2] ## numero de covariaveis com fracao de cura, para risco tiramos um (beta0)
betas.cure = par[(b + 2):(b + 1 + n.covars)]
betas.risk = par[(b + 5):(b + 4 + n.covars - 1)]
## calculo da populacao curada
pi = exp(x.matriz %*% betas.cure)/(1 + exp(x.matriz %*% betas.cure))
## calculo da populacao nao-curada
## informacoes exponencial por partes Potencia (PPE) para esquerda
s0.tl = PPE(time = time.l[delta==1], cuts = grid, levels = hazards, alpha = exp, type = "survival")
## informacoes exponencial por partes Potencia (PPE) para direita
s0.tr = PPE(time = time.r[delta==1], cuts = grid, levels = hazards, alpha = exp, type = "survival")
## contribuicao das covariaveis
sl = s0.tl^exp((x.matriz[,-1] %*% betas.risk))
sr = s0.tr^exp((x.matriz[,-1] %*% betas.risk))
p1 = Yi*(log(pi) + log(sl-sr))
p2 = (1-Yi)*log(1-pi)
log.vero = sum(p1,p2)
return(-1*log.vero)
}
loglik.int.fc2 = function(par, time.l, time.r,
grid, Yi, x.matriz){
b = length(grid) + 1 ## numero de intervalos
hazards = par[1:b] ## taxas de falha para os b intervalos
exp = par[b + 1] ## parametro de potencia
n.covars = dim(x.matriz)[2] ## numero de covariaveis com fracao de cura, para risco tiramos um (beta0)
betas.cure = par[(b + 2):(b + 1 + n.covars)]
betas.risk = par[(b + 5):(b + 4 + n.covars - 1)]
## calculo da populacao curada
pi = exp(x.matriz %*% betas.cure)/(1 + exp(x.matriz %*% betas.cure))
## calculo da populacao nao-curada
## informacoes exponencial por partes Potencia (PPE) para esquerda
s0.tl = PPE(time = time.l[delta==1], cuts = grid, levels = hazards, alpha = exp, type = "survival")
## informacoes exponencial por partes Potencia (PPE) para direita
s0.tr = PPE(time = time.r[delta==1], cuts = grid, levels = hazards, alpha = exp, type = "survival")
## contribuicao das covariaveis
sl = s0.tl^exp((x.matriz[,-1] %*% betas.risk))
sr = s0.tr^exp((x.matriz[,-1] %*% betas.risk))
p1 = Yi*(log(pi) + log(sl-sr))
p2 = (1-Yi)*log(1-pi)
log.vero = sum(p1,p2)
return(-1*log.vero)
}
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(1.2,0.5,0.3)
betas.risco = c(0.5,0.3)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 100, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
grid.obs = grid.obs[-c(1, length(grid))]
chutes = c(rep(0.4,length(grid)+1),1, 1.2, 0.3, 0.5, 0.5, 0.5)
loglik.int.fc2 = function(par, time.l, time.r,
grid, Yi, x.matriz){
b = length(grid) + 1 ## numero de intervalos
hazards = par[1:b] ## taxas de falha para os b intervalos
exp = par[b + 1] ## parametro de potencia
n.covars = dim(x.matriz)[2] ## numero de covariaveis com fracao de cura, para risco tiramos um (beta0)
betas.cure = par[(b + 2):(b + 1 + n.covars)]
betas.risk = par[(b + 5):(b + 4 + n.covars - 1)]
## calculo da populacao curada
pi = exp(x.matriz %*% betas.cure)/(1 + exp(x.matriz %*% betas.cure))
## calculo da populacao nao-curada
## informacoes exponencial por partes Potencia (PPE) para esquerda
s0.tl = PPE(time = time.l, cuts = grid, levels = hazards, alpha = exp, type = "survival")
## informacoes exponencial por partes Potencia (PPE) para direita
s0.tr = PPE(time = time.r, cuts = grid, levels = hazards, alpha = exp, type = "survival")
## contribuicao das covariaveis
sl = s0.tl^exp((x.matriz[,-1] %*% betas.risk))
sr = s0.tr^exp((x.matriz[,-1] %*% betas.risk))
p1 = Yi*(log(pi) + log(sl-sr))
p2 = (1-Yi)*log(1-pi)
log.vero = sum(p1,p2)
return(-1*log.vero)
}
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(1.2,0.5,0.3)
betas.risco = c(0.5,0.3)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 100, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
grid.obs = grid.obs[-c(1, length(grid))]
chutes = c(rep(0.4,length(grid)+1),1, 1.2, 0.3, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc2,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
Yi = dados$risk,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(1.2,0.5,0.3)
betas.risco = c(0.5,0.3)
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(1,0.5,0.3)
betas.risco = c(0.5,0.3)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 1000, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
grid.obs = grid.obs[-c(1, length(grid))]
chutes = c(rep(0.4,length(grid)+1),1, 1.2, 0.3, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc2,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
Yi = dados$risk,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(1.2,0.5,0.3)
betas.risco = c(0.5,0.3)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 1000, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
grid.obs = grid.obs[-c(1, length(grid))]
chutes = c(rep(0.4,length(grid)+1),1, 1, 0.5, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc2,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
Yi = dados$risk,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = F,
method = "Nelder-Mead",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
delta = dados$delta,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = F,
method = "Nelder-Mead",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
Yi = dados$risk,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
estimacao.intervalar$par
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc2,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
Yi = dados$risk,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
estimacao.intervalar2 = optim(par = chutes,
fn = loglik.int.fc,
gr = NULL,
hessian = F,
method = "Nelder-Mead",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
Yi = dados$risk,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar2$par
loglik.int.fc2 = function(par, time.l, time.r,
grid, Yi, x.matriz){
b = length(grid) + 1 ## numero de intervalos
hazards = par[1:b] ## taxas de falha para os b intervalos
exp = par[b + 1] ## parametro de potencia
n.covars = dim(x.matriz)[2] ## numero de covariaveis com fracao de cura, para risco tiramos um (beta0)
betas = par[(b + 2):(b + 1 + n.covars)]
## calculo da populacao curada
pi = exp(x.matriz %*% betas)/(1 + exp(x.matriz %*% betas))
## calculo da populacao nao-curada
## informacoes exponencial por partes Potencia (PPE) para esquerda
s0.tl = PPE(time = time.l, cuts = grid, levels = hazards, alpha = exp, type = "survival")
## informacoes exponencial por partes Potencia (PPE) para direita
s0.tr = PPE(time = time.r, cuts = grid, levels = hazards, alpha = exp, type = "survival")
## contribuicao das covariaveis
sl = s0.tl^exp((x.matriz[,-1] %*% betas[-1]))
sr = s0.tr^exp((x.matriz[,-1] %*% betas[-1]))
p1 = Yi*(log(pi) + log(sl-sr))
p2 = (1-Yi)*log(1-pi)
log.vero = sum(p1,p2)
return(-1*log.vero)
}
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.fc = c(0.823,-0.418,0.3)
parametros = c(taxas.de.falha, potencia, betas.fc)
dados = sim.cure.icen.mepp(N = 1000, prob.ber = 0.5, betas.cure = betas.cura,
betas= betas.fc, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(0.823,-0.5,0.3)
betas.risco = c(-0.5,0.3)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 1000, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
grid.obs = grid.obs[-c(1, length(grid))]
chutes = c(rep(0.4,length(grid)+1),1, 1, 0.5, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc2,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
Yi = dados$risk,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
chutes
parametros
length(chutes)
length(parametros)
time.l =  dados$L
time.r = dados$R
grid = grid.obs
delta = dados$delta
x.matriz = cbind(1,dados$X1, dados$X2)
betas.cure = betas.cura
betas.risk = betas.risco
hazards = taxas.de.falha
exp = potencia
grid = particoes
pi = exp(x.matriz %*% betas.cure)/(1 + exp(x.matriz %*% betas.cure))
taxas.de.falha
b = length(grid) + 1
b
parametros[1:b]
parametrosb+1
parametros[b+1]
parametros[b+1]
parametros[(b + 2):(b + 1 + n.covars)]
n.covars = 3
parametros[(b + 2):(b + 1 + n.covars)]
parametros[(b + 5):(b + 4 + n.covars - 1)]
loglik.int.fc2 = function(par, time.l, time.r,
grid, Yi, x.matriz){
b = length(grid) + 1 ## numero de intervalos
hazards = par[1:b] ## taxas de falha para os b intervalos
exp = par[b + 1] ## parametro de potencia
n.covars = dim(x.matriz)[2] ## numero de covariaveis com fracao de cura, para risco tiramos um (beta0)
betas.cure = par[(b + 2):(b + 1 + n.covars)]
betas.risk = par[(b + 5):(b + 4 + n.covars - 1)]
## calculo da populacao curada
pi = exp(x.matriz %*% betas.cure)/(1 + exp(x.matriz %*% betas.cure))
## calculo da populacao nao-curada
## informacoes exponencial por partes Potencia (PPE) para esquerda
s0.tl = PPE(time = time.l, cuts = grid, levels = hazards, alpha = exp, type = "survival")
## informacoes exponencial por partes Potencia (PPE) para direita
s0.tr = PPE(time = time.r, cuts = grid, levels = hazards, alpha = exp, type = "survival")
## contribuicao das covariaveis
sl = s0.tl^exp((x.matriz[,-1] %*% betas.risk))
sr = s0.tr^exp((x.matriz[,-1] %*% betas.risk))
p1 = Yi*(log(pi) + log(sl-sr))
p2 = (1-Yi)*log(1-pi)
log.vero = sum(p1,p2)
return(-1*log.vero)
}
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(0.823,-0.5,0.3)
betas.risco = c(-0.5,0.3)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 1000, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
grid.obs = grid.obs[-c(1, length(grid))]
chutes = c(rep(0.4,length(grid)+1),1, 1, 0.5, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc2,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
Yi = dados$risk,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
taxas.de.falha = c(0.6, 0.8, 0.9)
particoes = c(0.3,0.6)
potencia = 1.4
betas.cura = c(0.823,-0.5,0.3)
betas.risco = c(-0.7,0.1)
parametros = c(taxas.de.falha, potencia, betas.cura, betas.risco)
dados = sim.cure.icen.mepp(N = 1000, prob.ber = 0.5, betas.cure = betas.cura,
betas.risk = betas.risco, c1 = 4, c2 = 7,
lambdas = taxas.de.falha, grid = particoes, alpha = potencia)
## tentativa de estimacao por Maxima Verossimilhanca
grid.obs = time.grid.interval(li = dados$L, ri = dados$R,
type = "OBS", bmax = length(taxas.de.falha))
grid.obs = grid.obs[-c(1, length(grid))]
chutes = c(rep(0.4,length(grid)+1),1, 1, 0.5, 0.5, 0.5, 0.5)
## Metodo numerico BFGS
estimacao.intervalar = optim(par = chutes,
fn = loglik.int.fc2,
gr = NULL,
hessian = TRUE,
method = "BFGS",
time.l =  dados$L,
time.r = dados$R,
grid = grid.obs,
Yi = dados$risk,
x.matriz = cbind(1,dados$X1, dados$X2))
estimacao.intervalar$par
parametros
