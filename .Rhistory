if(!require(pacman)) install.packages("pacman"); library(pacman)
p_load(eha, dplyr, maxLik)
## ajustar o script com as funcoes de sobrevivencia
source('C:/Users/NetoDavi/Desktop/survival_pibic/funcoes_sobrevivencia_pibic2023.R')
## funcao para calcular o bias%
bias = function(est.matrix, param.matrix){
bias.calculation = ((est.matrix - param.matrix)/param.matrix)*100
return(bias.calculation)
}
set.seed(10)
## ajustando a parametrizacao
tamanho.amostral = 600
## parametros do PPE
taxas.falha = c(0.2, 0.4, 0.65)
particoes = c(0.5, 0.9)
potencia = 1.4
beta = c(0.5, 2.3)
x1 = rnorm(n = tamanho.amostral, mean = 0, sd = 1)
x2 = rbinom(n = tamanho.amostral, size = 1, prob = 0.5)
x.matriz = as.matrix(cbind(x1, x2))
# numero de iteracoes a acontecer
n.iter = 50
iteracao = 1 ## iniciador do laco while
## armazenamento
matrix.iter = matrix(data = 0, nrow = n.iter,
ncol = length(taxas.falha) + length(potencia) + length(beta))
matrix.var = matrix(data = 0, nrow = n.iter,
ncol = length(taxas.falha) + length(potencia) + length(beta))
iter.error = c()
while (iteracao <= n.iter) {
result = tryCatch({
cat("Realizando iteracao: ", iteracao, "/", n.iter, "\n", sep = "")
## geracao de dados do tempo de falha e tempo com censura
tempo.falha = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
tempo.censura = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
## geracao do tempo e censura
tempo = pmin(tempo.falha, tempo.censura)
delta = ifelse(tempo.falha <= tempo.censura, 1, 0)
## particao para a estimacao
grid = time.grid.obs.t(tempo, delta, n.int = length(taxas.falha))
grid = grid[-c(1, length(grid))]
chutes = c(rep(0.1,length(grid)+1),1,0.5,1)
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
## salvar resultados
matrix.iter[iteracao,1:length(taxas.falha)] = estimacao.teste.cox$par[1:length(taxas.falha)]
matrix.iter[iteracao,length(taxas.falha) + 1] = estimacao.teste.cox$par[length(taxas.falha) +1]
matrix.iter[iteracao, (length(taxas.falha)+2):(length(taxas.falha)+1+length(beta))] = estimacao.teste.cox$par[(length(taxas.falha)+2):(length(taxas.falha)+1+length(beta))]
matrix.var[iteracao,] = diag(solve(-estimacao.teste.cox$hessian))
iteracao = iteracao + 1
estimacao.teste.cox
}, error = function(e){
print(paste0("Erro na iteracao ", iteracao, ": ", conditionMessage(e)))
# valor nulo nessa iteracao
NULL
}
)
# continua as iteracoes se tiver um erro
if(is.null(result$convergence)){
iter.error[iteracao] = as.character(iteracao)
#iteracao = iteracao
}
# caso contrario, com os resultados
}
## geracao de dados do tempo de falha e tempo com censura
tempo.falha = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
tempo.censura = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
## geracao do tempo e censura
tempo = pmin(tempo.falha, tempo.censura)
delta = ifelse(tempo.falha <= tempo.censura, 1, 0)
## particao para a estimacao
grid = time.grid.obs.t(tempo, delta, n.int = length(taxas.falha))
grid = grid[-c(1, length(grid))]
chutes = c(rep(0.1,length(grid)+1),1,0.5,1)
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
estimacao.teste.cox$hessian
solve(estimacao.teste.cox$hessian)
sqrt(solve(estimacao.teste.cox$hessian))
sqrt(diag(solve(estimacao.teste.cox$hessian)))
sqrt(diag(solve(estimacao.teste.cox$hessian)))^2
sqrt(diag(solve(estimacao.teste.cox$hessian)))^2
sqrt(diag(solve(-estimacao.teste.cox$hessian)))
library(maxLik)
loglik <- function(param) {
# param: vector of 2, c(mean, standard deviation)
mu <- param[1]
sigma <- param[2]
ll <- -0.5*N*log(2*pi) - N*log(sigma) - sum(0.5*(x - mu)^2/sigma^2)
# can use dnorm(x, mu, sigma, log=TRUE) instead
ll
}
x <- rnorm(100, 1, 2) # use mean=1, stdd=2
N <- length(x)
res <- maxLik(loglik, start=c(0,1)) # use 'wrong' start values
summary(res)
res$hessian
maxLik(logLik = loglik.cox, method = "BFGS",
start = chutes)
maxLik(logLik = loglik.cox, method = "BFGS",
start = chutes)
maxLik(logLik = loglik.cox, method = "BFGS",
start = chutes, intervalos = grid,
tempos = tempo, censura = delta,
covariaveis = x.matriz)
est.max.lik = maxLik(logLik = loglik.cox, method = "BFGS",
start = chutes, intervalos = grid,
tempos = tempo, censura = delta,
covariaveis = x.matriz)
est.max.lik$hessian
sqrt(diag(solve(-est.max.lik$hessian)))
diag(solve(-est.max.lik$hessian))
sqrt(diag(solve(est.max.lik$hessian)))
est.max.lik$hessian
solve(est.max.lik$hessian)
solve(-est.max.lik$hessian)
loglik.cox = function(par,tempos,
censura,
intervalos,
covariaveis){
b = length(intervalos) + 1 ## numero de intervalos
hazards = par[1:b]             ## taxas de falha dos b intervalos
exp = par[b +1] ## alpha: ultimo elemento dos parametrtos a ser estimado
n.covars = dim(covariaveis)[2]
betas = par[(b + 2): (b + 1 + n.covars)]
## informacoes exponencial por partes (PE)
#F0.t = ppch(q = tempos, cuts = intervalos, levels = hazards)
#f0.t = dpch(x = tempos, cuts = intervalos, levels = hazards)
## informacoes exponencial por partes Potencia (PPE)
#F1.t = (F0.t)^exp
#f1.t = exp*(F0.t)^(exp-1) * f0.t
s1.t = PPE(time = tempos, cuts = intervalos, alpha = exp,levels = hazards, type = "survival")
h1.t = PPE(time = tempos, cuts = intervalos, alpha = exp,levels = hazards, type = "harzard")
# h1.t = PPE(time = tempos, cuts = intervalos,
#           levels = hazards, alpha = exp, type = 'hazard')
#
# s1.t = PPE(time = tempos, cuts = intervalos,
#           levels = hazards, alpha = exp, type = 'survival')
## efeito das covariaveis
pred.linear = covariaveis %*% betas
harzard.cox = (h1.t*exp(pred.linear))
sobrevivencia.cox = (s1.t^(exp(pred.linear)))
## Likelihood function
log.verossimilhanca = sum((censura*log(harzard.cox)) + log(sobrevivencia.cox))
return(-1*log.verossimilhanca)
}
## ajustar o script com as funcoes de sobrevivencia
source('C:/Users/NetoDavi/Desktop/survival_pibic/funcoes_sobrevivencia_pibic2023.R')
## geracao de dados do tempo de falha e tempo com censura
tempo.falha = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
tempo.censura = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
## geracao do tempo e censura
tempo = pmin(tempo.falha, tempo.censura)
delta = ifelse(tempo.falha <= tempo.censura, 1, 0)
## particao para a estimacao
grid = time.grid.obs.t(tempo, delta, n.int = length(taxas.falha))
grid = grid[-c(1, length(grid))]
chutes = c(rep(0.1,length(grid)+1),1,0.5,1)
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
s1.t = PPE(time = tempos, cuts = intervalos, alpha = exp,levels = hazards, type = "survival")
h1.t = PPE(time = tempos, cuts = intervalos, alpha = exp,levels = hazards, type = "harzard")
tempo
s1.t = PPE(time = tempo, cuts = particoes, alpha = potencia,levels = taxas.falha, type = "survival")
set.seed(10)
## ajustando a parametrizacao
tamanho.amostral = 600
## parametros do PPE
taxas.falha = c(0.2, 0.4, 0.65)
particoes = c(0.5, 0.9)
potencia = 1.4
beta = c(0.5, 2.3)
x1 = rnorm(n = tamanho.amostral, mean = 0, sd = 1)
x2 = rbinom(n = tamanho.amostral, size = 1, prob = 0.5)
x.matriz = as.matrix(cbind(x1, x2))
# numero de iteracoes a acontecer
n.iter = 50
iteracao = 1 ## iniciador do laco while
## armazenamento
matrix.iter = matrix(data = 0, nrow = n.iter,
ncol = length(taxas.falha) + length(potencia) + length(beta))
matrix.var = matrix(data = 0, nrow = n.iter,
ncol = length(taxas.falha) + length(potencia) + length(beta))
iter.error = c()
## geracao de dados do tempo de falha e tempo com censura
tempo.falha = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
tempo.censura = gen.mepp.cox(n = tamanho.amostral, lambda.par = taxas.falha, alpha.par = potencia,
cuts = particoes, x.mat = x.matriz, beta.par = beta)
## geracao do tempo e censura
tempo = pmin(tempo.falha, tempo.censura)
delta = ifelse(tempo.falha <= tempo.censura, 1, 0)
## particao para a estimacao
grid = time.grid.obs.t(tempo, delta, n.int = length(taxas.falha))
grid = grid[-c(1, length(grid))]
chutes = c(rep(0.1,length(grid)+1),1,0.5,1)
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
loglik.cox = function(par,tempos,
censura,
intervalos,
covariaveis){
b = length(intervalos) + 1 ## numero de intervalos
hazards = par[1:b]             ## taxas de falha dos b intervalos
exp = par[b +1] ## alpha: ultimo elemento dos parametrtos a ser estimado
n.covars = dim(covariaveis)[2]
betas = par[(b + 2): (b + 1 + n.covars)]
## informacoes exponencial por partes (PE)
#F0.t = ppch(q = tempos, cuts = intervalos, levels = hazards)
#f0.t = dpch(x = tempos, cuts = intervalos, levels = hazards)
## informacoes exponencial por partes Potencia (PPE)
#F1.t = (F0.t)^exp
#f1.t = exp*(F0.t)^(exp-1) * f0.t
s1.t = PPE(time = tempo, cuts = intervalos, alpha = exp,levels = hazards, type = "survival")
h1.t = PPE(time = tempo, cuts = intervalos, alpha = exp,levels = hazards, type = "harzard")
# h1.t = PPE(time = tempos, cuts = intervalos,
#           levels = hazards, alpha = exp, type = 'hazard')
#
# s1.t = PPE(time = tempos, cuts = intervalos,
#           levels = hazards, alpha = exp, type = 'survival')
## efeito das covariaveis
pred.linear = covariaveis %*% betas
harzard.cox = (h1.t*exp(pred.linear))
sobrevivencia.cox = (s1.t^(exp(pred.linear)))
## Likelihood function
log.verossimilhanca = sum((censura*log(harzard.cox)) + log(sobrevivencia.cox))
return(-1*log.verossimilhanca)
}
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
## ajustar o script com as funcoes de sobrevivencia
source('C:/Users/NetoDavi/Desktop/survival_pibic/funcoes_sobrevivencia_pibic2023.R')
## Metodo numerico BFGS
estimacao.teste.cox = optim(par = chutes,
fn = loglik.cox,
gr = NULL,
hessian = TRUE,
method = "BFGS",
tempos = tempo,
censura = delta,
intervalos = grid,
covariaveis = x.matriz)
